.TH oo2c 1
.UC 5
.SH NAME
oo2c \- Oberon-2 compiler
.SH SYNOPSIS
.B oo2c
.RI [ options ]
.IR <module> ...
.br
.B oo2c
.RI ( --make | -M )
.RI [ options ]
.I <module>
.br
.B oo2c
.I --build-package
.RI [ options ]
.I <package>
.br
.B oo2c
.I --install-package
.RI [ options ]
.I <package>
.br
.B oo2c
.I --uninstall-package
.RI [ options ]
.I <package>
.SH NOTE
This document is a subset of corresponding chapter of the 
.B OOC2 Reference 
.BR Manual .
It covers the basic functionality of
.BR oo2c .
For a complete overview of
.BR oo2c 's
features, the reader is referred to the reference manual (see below).
.SH DESCRIPTION
The default mode of
.B oo2c
assumes that all arguments are names of modules or source files and
tries to compile them to C code.  Compiling a single module in this
way can be used to do a syntax check on a module.  Module names are
resolved by searching in the repositories listed in the corresponding
section of the compiler configuration.

The option
.I --make 
(or 
.I -M
for short) turns a set of Oberon-2 modules into an executable program.
The single argument can be either the name of a module or a module's
file name.  Again, the compiler searches the configured repositories
to resolve module names.  The compiler inspects all modules imported
directly or indirectly by the given main module, and generates new C
code for any modules that have not been compiled yet, or whose C code
is not up to date anymore.  Then, all necessary object files are
generated by invoking the C compiler.  The final step links object
files and libraries into an executable program with the same name as
the main module.  Note that, unlike the Oberon System, there is no
notion of
.I commands
(i.e., parameterless exported procedures, which can be activated
directly by the user).  Instead, the module body of the main module
specifies the program's execution sequence.

With 
.IR --build-package ,
.IR --install-package ,
and
.I --uninstall-package
packages are compiled, installed, and uninstalled.  A package is a set
of libraries, exectuables, resource files, option definitions, and
pragma definitions.  It is described in it repository's
.I pkginfo.xml
file.
.SH OPTIONS
.TP
.B --repository <directory>, -r <directory>
Add a directory to the list of repositories used by the compiler.  A
repository has a fixed directory structure, with subdirectory
.I src/
holding source files,
.IR sym/ ,
.IR obj/ ,
and
.IR bin/
storing symbol files, C header and code files, object files and
binaries produced by the compiler, and so on.  Repositories are
searched from right to left, with command line arguments taking
precedence of entries in the compiler's configuration file.  By
default, the current working directory is part of the list of
repositories.
.TP
.B --optimize, -O
Currently no effect.
.TP
.B --no-rtc
Remove all run-time checks from the generated code.  Typically, this
produces a large speedup.
.TP
.B --verbose, -v
Currently no effect.
.TP
.B --warnings, -w
Currently no effect.
.TP
.B --all, -A
Currently no effect.
.TP
.B --cc <string>
The name of the C compiler.
.TP
.B --cflags <string>
These flags are added to the C compiler's argument list when
translating a C file into an object file.
.TP
.B --cppflags <string>
Flags targeted at the C compiler's preprocessor.
.TP
.B --ldflags <string>
The value of this string is appended to the link command.
.TP
.B --libs <string>
The value of this string is added to the very end of the link command.
.TP
.B --libtool <string>
The name of the
.B libtool
binary.  If the value is
.IR no ,
the the compiler does not produce static or shared libraries at all.
.TP
.B --libdir <string>
Specify the directory where libraries should be installed.  Note that
the same destination directory has to be used for both library
creation (with
.IR --build-package )
and library installation (with
.IR --install-package ).
.TP
.B --bindir <string>
Binaries are installed into this directory by
.IR --install-package .
.TP
.B --oocdir <string>
All module data produced by the compiler, like symbol files, header
files, or package meta data, are copied by
.I --install-package 
into this directory.
.TP
.B --install <string>
.TP
.B --install-program <string>
.TP
.B --install-data <string>
.TP
.B --uninstall <string>
Commands to install directories, binaries, and data files, and the
command used to remove them with 
.IR --uninstall-package .
.TP
.B --xsltproc <string>
Name of the XSLT processor.  It produces the HTML version of the
documentation of library modules.  The value
.I no
disables HTML documentation.
.TP
.B --config <file>
Use given file name for the configuration file.
.SH INITIALIZATION FILES
An initialization file is composed of sections; each section is
introduced by its keyword, followed by data in a section-dependent
formant, and terminated by the keyword
.IR END .
Only the sections 
.I PATHS
and
.I INCLUDE
are explained in this man page.  For information about the other
sections refer to the OOC Reference Manual.

When looking for a particular file, 
.B oo2c
searches the directories defined in the 
.I PATHS
section of the initialization file.  The
.I PATHS
section lists a number of wildcard strings, which are used to
determine which directories should be scanned for matching file names.

The syntax of the 
.I PATHS
section is defined like this:

  paths_section  = "PATHS" {source_pattern} "END".
  source_pattern = "GET" wildcard_list "FROM" path {path}.
  wildcard_list  = wildcard {[","] wildcard}.
  wildcard       = name | string.
  path           = ( name | string ) [";"].

A wildcard may contain the special characters `*' and `?'.  A `*'
matches an arbitrary number of characters (including none at all),
whereas `?' matches exactly one character.  Writing `[RCS]' after a
wildcard signals that a file matching the pattern might be under
control of the Revision Control System (RCS), and should be checked
out if no working file exists.

Any non-absolute path (i.e., all path strings not starting with a `/'
or a `~') is interpreted relative to the directory the compiler, or
tool, was started from.  Whenever a program is invoked from a
different directory, these relative path names will then resolve
differently.  If the intention is to always use the exact same
directories for all invocations, all paths in the initialization file
must be absolute.

When looking for a particular file, say 
.IR foo ,
the list of patterns is scanned from top to bottom.  For every match,
the list of directories is tested from left to right.  The first
directory that contains a file with the requested name is used.  If
the file cannot be found in any of these directories, the simple file
name is used.  If RCS support is enabled for 
.IR foo ,
then the files 
.I <dir>/RCS/foo,v
and 
.I <dir>/foo,v
are also searched for in these directories.

Note that, if a module name is passed as argument from the command
line, the standard suffix 
.I .Mod
is appended, and the resulting file name is searched for using the
above mechanism.  Also, if a file name that contains a directory part
is used, no searching is done at all; the file name is used exactly as
specified.

When trying to decide where to place a generated file (e.g., one of
the numerous intermediate files with C code), 
.B oo2c
uses a simplified version of the mechanism described above.  It looks
for the first matching wildcard, and uses the first directory in that
list; the newly created file is written to this directory.  It does
not matter if the file exists beforehand or not, or if a file of the
same name exists in any of the other listed directories.

The default setting is to have the compiler place generated files in
the current directory.  To have these files put away in other
directories the user should put something like the following lines
into his personal initialization file 
.IR ~/.oo2crc:

  PATHS
  GET *.Sym, *.Lib FROM sym
  GET *.c, *.d, *.h, *.o FROM obj 
  END

This places all symbol files in directory 
.IR sym ,
all generated C code in directory
.IR obj , 
and executables in the current directory.  The subdirectories 
.I sym
and 
.I obj
have to exist in the current directory, otherwise the compiler will
abort with an error message.  Note that with the default setup
.I ~/.oo2crc
merely extends the system wide path configuration, it does 
.I not
replace it.

Additional control over the configuration data is allowed by the
special initialization file section
.IR INCLUDE .
It is a simple, but efficient, way to add personalized or project
specific configuration details to the global default settings.  The
format of an 
.I INCLUDE
section is simply 
.I INCLUDE <file> 
.IR END ,
which causes the entire contents of 
.I <file>
to be processed as if those contents had appeared in place of the
.I INCLUDE
statement.

For example, the default initialization file contains the following
statement to include a user's personalized settings:

  INCLUDE ~/.oo2crc END

The file 
.I .oo2crc
from the user's home directory is then parsed just as though it were
part of the initialization file at the place of the 
.I INCLUDE
statement.
.SH ERROR MESSAGES
Any errors encountered while parsing a source file 
.I foo.Mod
are written to
.I stdout
like this:

  In file foo.Mod:
  <pos>: <num> <error message>

The integer <pos> refers to the position of the error in the file (the
first character has position 0).  The integer <num> is the error
number.  The rest of the line is a plain text error message.  The
message format can be changed with the filter program
.BR ooef .
.SH ENVIRONMENT
.I OO2CRC
overrides the name of the configuration file.
.SH FILES
.nf
.ta \w'file.c, file.dXXX'u
file.Mod        Source code of Oberon-2 Module.
file.Sym        Symbol file with public interface of module.
file.oh         Header file with C level interface of module.
file.c, file.d  Generated ANSI-C code for module.
file.o          Object file derived from file.d and file.c.
.Sp
.fi

In the directory 
.IR <prefix>/lib/oo2c :

.nf
.ta \w'file.c, file.dXXX'u
oo2crc.xml      Configuration file with defaults for options, pragmas,
                and repositories.
lib/__*.h       Auxiliary files of the compiler.
.Sp
.fi
.SH DIAGNOSTICS
The exit status is non zero, if, and only if, an error occurred during
compilation.
.SH SEE ALSO
ooef(1), oowhereis(1)

Additional topics covered by the OOC2 Reference Manual: installing
oo2c, use of initialization files, interfacing to C code, creating
static and shared libraries from Oberon-2 modules, and using the
Oberon-2 mode for Emacs.

The OOC Reference Manual can be obtained from the OOC Home Page at
http://ooc.sourceforge.net/.  It is available in info, Postscript, HTML,
and texinfo format.

Please note: At the time of writing, only the OOC Reference Manual for
version 1 is available.
.SH AUTHOR
Michael van Acken <mia@de.uu.net>
