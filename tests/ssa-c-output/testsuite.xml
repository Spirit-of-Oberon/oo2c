<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE testsuite-ext
          SYSTEM "../../rsrc/OOC/TestFramework/testcases-ext.dtd">

<testsuite-ext profile="Tests code emitted by SSA/C back-end">
<!--<testsuite-ext
  profile="Tests code emitted by SSA/C back-end"
  select ="&SetupTestCasesWithOut; quicksort1">-->
  
  &TestSetupWithOut;
    
  <testcases profile="OOC/SSA: Quality Check C Code" default-lang="O2">
    <test id="var1" type="run" file="Var1.Mod" output="Var1.Ref">
      Reading a variable with a known value: instead of accessing
      memory, the known value should be used, and the local variable
      <code>F.y</code> should not be read.
    </test>
    
    <test id="var2" type="run" file="Var2.Mod" output="Var2.Ref">
      Assignment masked by subsequent assignment to the same var.
      The first assignment should be discarded, but the second must survive.
    </test>
    
    <test id="var3" type="run" file="Var3.Mod" output="Var3.Ref">
      Return value is taken from a local variable that is set in an 
      <code>IF</code> statement.  The assignments should be converted
      from memory writes to register values.
    </test>
    
    <test id="var3b" type="run" file="Var3b.Mod" output="Var3b.Ref">
      Similar to the preceding test case, with the added complication
      of a nested <code>IF</code> statement.
    </test>
    
    <test id="var3c" type="run" file="Var3c.Mod" output="Var3c.Ref">
      Like <code>var3</code>, with the added complication that the
      life time of a local variable extends across an <code>IF</code>
      statement.  The variable's value should not be passed through
      the select.
    </test>
    
    <test id="var4" type="run" file="Var4.Mod" output="Var4.Ref">
      Return value is taken from a global variable that is set in an 
      <code>IF</code> statement.  The assignments should remain,
      because the changed variable is visible outside the procedure.
    </test>
    
    <test id="var4b" type="run" file="Var4b.Mod" output="Var4b.Ref">
      Similar to the preceding test case, with the added complication
      of a nested <code>IF</code> statement.
    </test>
    
    <test id="var5" type="run" file="Var5.Mod" output="Var5.Ref">
      Like test case <code>var4</code>, but the global variable is
      set as a side-effect of a procedure call.  Here, the return
      value must be read from memory.
    </test>

    <test id="var5b" type="run" file="Var5b.Mod" output="Var5b.Ref">
      Like test case <code>var5</code>, but with a twist that should
      trigger a different code path in <code>OOC:SSA:Destore</code>.
    </test>

    <test id="var6" type="run" file="Var6.Mod" output="Var6.Ref">
      A combination of test cases <code>var4</code> and
      <code>var5</code>: one branch of the <code>IF</code> sets the
      global variable through an assignment, the other by means of a
      side-effect of a procedure call.  There should be one read of
      the global variable <code>x</code>, right after the
      <code>IF</code> statement.
    </test>

    <test id="var6b" type="run" file="Var6b.Mod" output="Var6b.Ref">
      Like <code>var6</code>, except that the branches of the
      <code>IF</code> statement have been swapped.
    </test>

    <test id="var7" type="run" file="Var7.Mod" output="Var7.Ref">
      Incrementing a local variable within a loop.  The variable
      should be kept in a register.
    </test>
    <test id="var7b" type="run" file="Var7b.Mod" output="Var7b.Ref">
      Incrementing a <em>global</em> variable within a loop.  The
      variable should not be read, although its value must be written
      with each iteration.  (Or, if the compiler is clever enough,
      once after the final iteration.)
    </test>
    <test id="var7c" type="run" file="Var7c.Mod" output="Var7c.Ref">
      Like <code>var7</code>, with the added complication that the
      life time of a local variable extends across an <code>IF</code>
      statement.  The variable's value should not be passed through
      the loop.
    </test>
    <test id="var7d" type="run" file="Var7d.Mod" output="Var7d.Ref">
      Equivalent to <code>var7</code>, but the loop uses a
      <code>LOOP</code> statement.
    </test>
    
    <test id="var8" type="run" file="Var8.Mod">
      Zeroing a character array using a <code>FOR</code> loop.  The
      loop variable should be kept in a register from beginning to end.
    </test>
    
    <test id="var9" type="run" file="Var9.Mod">
      Zeroing a character array using a <code>LOOP</code> loop.  The
      loop variable should be kept in a register from beginning to end.
    </test>
    
    <test id="var10" type="run" file="Var10.Mod">
      A somewhat convoluted exit out of a <code>LOOP</code> loop.  The
      return statement can only see the value <code>x=1</code> ever,
      and an argument <code>FALSE</code> triggers and endless loop.
    </test>
    

    <test id="swap1" type="run" file="Swap1.Mod" output="Swap1.Ref">
      Swapping to values.  The swap is done in memory.  Register
      variables are used as temporary stores.
    </test>
    <test id="swap2" type="run" file="Swap2.Mod" output="Swap2.Ref">
      Swapping to values.  The swap is done in the register file.  A
      temporary variable must be created to avoid clobbering a swapped
      value.
    </test>


    <test id="varpar1" type="run" file="VarPar1.Mod" output="VarPar1.Ref">
      Assignment to <code>VAR</code> parameter does not alias with
      local variable.  This means there is no need to retrieve either
      the local variable nor the variable parameter from memory.
    </test>
    
    <test id="varpar1b" type="run" file="VarPar1b.Mod" output="VarPar1b.Ref">
      Assignment to <code>VAR</code> parameter may alias with a global
      variable.  This means that the global variable needs to be
      retrieved from memory after an assignment to the
      <code>VAR</code> parameter.
    </test>
    
    <test id="varpar1c" type="run" file="VarPar1c.Mod" output="VarPar1c.Ref">
      Assignment to <code>VAR</code> parameter that cannot alias with
      a global variable because of its different type.  This means
      there is no need to retrieve either the global variable nor the
      variable parameter from memory.
    </test>


    <test id="quicksort1" type="run"
          file="Quicksort1.Mod" output="Quicksort1.Ref">
      A compact quicksort implementation.
    </test>


    <test id="cse1" type="run" file="Cse1.Mod">
      Common subexpression elimination must not merge the two calls to
      <code>NEW</code>.
    </test>
    <test id="cse2" type="run" file="Cse2.Mod">
      Common subexpression elimination must not merge move the memory
      access <code>p.x</code> over the guard <code>x#NIL</code>.
    </test>
    <test id="cse3" type="run" file="Cse3.Mod" output="Cse3.Ref">
      Check that common expressions are detected properly if a value
      contributes multiple times to an instruction.
    </test>
  </testcases>
</testsuite-ext>
