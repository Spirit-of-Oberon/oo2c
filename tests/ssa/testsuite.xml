<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE testsuite-ext
          SYSTEM "../../rsrc/OOC/TestFramework/testcases-ext.dtd">

<testsuite-ext profile="Test Suite for Framework Testing">

<!--<testsuite-ext
  profile="Test Suite for Framework Testing"
  select ="&SetupTestCasesWithOut; opString1 opString2 opString3 opString4 opString5 opString6">-->

<!--<testsuite-ext
  profile="Test Suite for Framework Testing"
  select ="&SetupTestCasesWithOut; proc3 proc4 proc5">-->

  &TestSetupWithOut;
    
  <testcases profile="OOC2 Development" default-lang="O2">
    <test id="assign1" type="reject" file="Assign1.Mod">
      Left side of an assignment is a constant.
    </test>
    <test id="assign2" type="reject" file="Assign2.Mod">
      Left side of an assignment is a type-bound procedure.
    </test>
    <test id="assign_ro" type="accept" file="AssignRO.Mod">
      Prepare exports for read-only tests.
    </test>
    <test id="assign3" type="reject" file="Assign3.Mod">
      Assignment to a variable that is exported read-only.
    </test>
    <test id="assign4" type="reject" file="Assign4.Mod">
      Assignment to a record field that is exported read-only.
    </test>
    <test id="assign5" type="reject" file="Assign5.Mod">
      Right side of assignment is a type name.
    </test>
    <test id="assign6" type="reject" file="Assign6.Mod">
      Right side of assignment is a module name.
    </test>
    <test id="assign7" type="reject" file="Assign7.Mod">
      Left side of assignment is an open array variable.
    </test>
    <test id="assign8" type="reject" file="Assign8.Mod">
      Trying to assign <code>NIL</code> to a <code>LONGINT</code>
      variable.
    </test>
    <test id="assign9" type="reject" file="Assign9.Mod">
      Trying to assign a string constant that is too long.
    </test>
    <test id="assign10" type="reject" file="Assign10.Mod">
      Procedure assignment: number of arguments differ.
    </test>
    <test id="assign11" type="reject" file="Assign11.Mod">
      Procedure assignment: result type differs.
    </test>
    <test id="assign12" type="reject" file="Assign12.Mod">
      Procedure assignment: type of parameter differs.
    </test>
    <test id="assign13" type="reject" file="Assign13.Mod">
      Procedure assignment: parameter differs in variable/value mode.
    </test>
    <test id="assign14" type="reject" file="Assign14.Mod">
      Procedure assignment: number of arguments differ.
    </test>
    
    <test id="return1" type="reject" file="Return1.Mod">
      <code>RETURN</code> of a procedure has an expression.
    </test>
    <test id="return2" type="reject" file="Return2.Mod">
      <code>RETURN</code> of a function procedure no expression.
    </test>
    <test id="return3" type="reject" file="Return3.Mod">
      Value of the <code>RETURN</code> is not assignment compatible to
      the function's result type.
    </test>
    <test id="return4" type="reject" file="Return4.Mod">
      <code>RETURN</code> in the module body has an expression.
    </test>
    
    <test id="proc1" type="reject" file="Proc1.Mod">
      Procedure call syntax, but the designator in front of the
      argument list is an integer variable.
    </test>
    <test id="proc2" type="reject" file="Proc2.Mod">
      Calling a function procedure in a statement.
    </test>
    <test id="proc3" type="reject" file="Proc3.Mod">
      Calling a procedure with too few arguments.
    </test>
    <test id="proc4" type="reject" file="Proc4.Mod">
      Calling a procedure with parameters without any argument list.
    </test>
    <test id="proc5" type="reject" file="Proc5.Mod">
      Calling a procedure more arguments than formal parameters.
    </test>
    
    <test id="function1" type="run"
      file="../compile/HOTFunction1.Mod" output="../compile/HOTFunction1.Ref">
      A very simple function: No input arguments, and a return
      statement with a constant expression.
    </test>
    <test id="function2" type="run"
      file="../compile/HOTFunction2.Mod" output="../compile/HOTFunction2.Ref">
      Another very simple function: The input parameter is used as the
      function's return value, without any transformation.
    </test>
    <test id="function3" type="run"
      file="HOTFunction3.Mod" output="HOTFunction3.Ref">
      Another very simple function: The input parameter is copied to 
      a local variable, which is subsequently used as the
      function's return value.
    </test>
    
    <test id="if1" type="run"
      file="HOTIf1.Mod" output="HOTIf1.Ref">
      A simple <code>IF-ELSE-END</code> statement, using a
      boolean parameter as guard.
    </test>
    
    <test id="if2" type="run"
      file="HOTIf2.Mod" output="HOTIf2.Ref">
      A simple <code>IF-END</code> statement, using a boolean parameter
      as guard.
    </test>
    
    <test id="if3" type="run"
      file="HOTIf3.Mod" output="HOTIf3.Ref">
      A simple <code>IF-ELSIF-ELSE-END</code> statement, using 
      boolean parameters as guards.
    </test>
    
    <test id="if4" type="reject" file="HOTIf4.Mod">
      Guard is not a boolean expression.
    </test>
    
    <test id="with1" type="run" file="With1.Mod" output="With1.Ref">
      A simple <code>WITH</code> statement, serving as a sequence
      of type tests.
    </test>
    
    <test id="with2" type="run" file="With2.Mod" output="With2.Ref">
      A simple <code>WITH</code> statement.  Fields of the guarded
      variable are accessed under the guard.  The variable is
      a parameter, but there is no recursive call involved.  That is,
      a compiler passes this test even if it modifies the signature
      of a procedure within a branch of a <code>WITH</code>.
    </test>
    
    <test id="with3" type="error" file="With3.Mod">
      Check that a run-time error is reported if none of the guards
      triggers, and the <code>WITH</code> has no <code>ELSE</code>
      part.
    </test>
    
    <test id="function4" type="run"
      file="HOTFunction4.Mod" output="HOTFunction4.Ref">
      Another simple function: The boolean input parameter selects
      between one of the two <code>RETURN</code> statements in
      the <code>IF</code> statement.
    </test>
    
    <test id="function5" type="run"
      file="HOTFunction5.Mod" output="HOTFunction5.Ref">
      Yet another simple function: Increment input value by one and
      return the result.
    </test>
    
    <test id="designator1" type="run"
      file="HOTDesignator1.Mod" output="HOTDesignator1.Ref">
      Designator test: access of elements of a character array.
      The array is passed as a parameter to the function, as is
      the index.
    </test>
    
    <test id="function6" type="run"
      file="HOTFunction6.Mod" output="HOTFunction6.Ref">
      Simple functions: Compare character parameter with constant
      character and return different integer values depending on the result.
    </test>
    <test id="function7" type="error" file="HOTFunction7.Mod">
      An error should be signaled if control reaches the end of a
      function.
    </test>
    <test id="function8" type="reject" file="HOTFunction8.Mod">
      Calling a normal procedure as a function.
    </test>

    <test id="loop1" type="run"
      file="HOTLoop1.Mod" output="HOTLoop1.Ref">
      Loop variant <code>REPEAT-UNTIL</code>: Calculate string length.
    </test>
    
    <test id="loop2" type="run"
      file="HOTLoop2.Mod" output="HOTLoop2.Ref">
      Loop variant <code>WHILE-DO</code>: Calculate string length.
    </test>
    
    <test id="loop3" type="run"
      file="HOTLoop3.Mod" output="HOTLoop3.Ref">
      Loop variant <code>LOOP-EXIT-END</code>: Calculate string length.
    </test>
    
    <test id="loop4" type="run"
      file="HOTLoop4.Mod" output="HOTLoop4.Ref">
      Loop variant <code>LOOP-EXIT-EXIT-END</code>: Calculate <code>x
      DIV 10</code> in a rather silly way for <code>0 &lt;= x &lt; 20</code>.
    </test>
    
    <test id="loop5" type="run"
      file="HOTLoop5.Mod" output="HOTLoop5.Ref">
      Nested <code>REPEAT-UNTIL</code> loops.
    </test>
    
    <test id="loop6" type="run" file="HOTLoop6.Mod">
      Nested loops that triggered a bug in the SSA back-end.
    </test>
    
    <test id="loop7" type="reject" file="HOTLoop7.Mod">
      Guard of <code>WHILE</code> is not boolean.
    </test>
    
    <test id="loop8" type="reject" file="HOTLoop8.Mod">
      Termination criterion of <code>REPEAT</code> is not boolean.
    </test>
    
    <test id="loop9" type="reject" file="HOTLoop9.Mod">
      <code>EXIT</code> outside of of a <code>LOOP</code>.
    </test>
 
    
    <test id="for1" type="reject" file="For1.Mod">
      Loop variable is an array element.
    </test>
    <test id="for2" type="reject" file="For2.Mod">
      Loop variable is a type name.
    </test>
    <test id="for3" type="reject" file="For3.Mod">
      Loop variable is of character type.
    </test>
    <test id="for4" type="reject" file="For4.Mod">
      Start of loop is not assignment compatible to loop variable.
    </test>
    <test id="for5" type="reject" file="For5.Mod">
      End of loop is not assignment compatible to loop variable.
    </test>
    <test id="for6" type="reject" file="For6.Mod">
      Type of loop variable does not include step.
    </test>
    <test id="for7" type="reject" file="For7.Mod">
      Step value is not a constant.
    </test>
    <test id="for8" type="reject" file="For8.Mod">
      Step value is zero.
    </test>
    <test id="for9" type="run" file="For9.Mod" output="For9.Ref">
      For loop with positive step value.
    </test>
    <test id="for10" type="run" file="For10.Mod" output="For10.Ref">
      For loop with negative step value.
    </test>
       
    <test id="case1" type="run" file="Case1.Mod" output="Case1.Ref">
      <code>CASE</code> statement using branches with one label, two
      labels, a range as a label, and an <code>ELSE</code> part.
      The selector is an integer value.
    </test>
    
    <test id="case2" type="error" file="Case2.Mod">
      Check that a run-time error is reported if none of the labels
      matches, and the <code>CASE</code> has no <code>ELSE</code>
      part.
    </test>
    
    <test id="case3" type="reject" file="Case3.Mod">
      Boolean value is not a valid <code>CASE</code> selector.
    </test>
    
    <test id="case4" type="reject" file="Case4.Mod">
      Case label is not constant.
    </test>
    
    <test id="case5" type="reject" file="Case5.Mod">
      Integer case label is not included in the select expression's
      type.
    </test>
    
    <test id="case6" type="reject" file="Case6.Mod">
      Character case label is not included in the select expression's
      type.
    </test>
    
    <test id="case7" type="reject" file="Case7.Mod">
      Duplicate label: earlier branch use same value.
    </test>
    
    <test id="case8" type="reject" file="Case8.Mod">
      Duplicate label: value appears twice in branch.
    </test>
    
    <test id="case9" type="reject" file="Case9.Mod">
      Duplicate label: range intersects with previous label.
    </test>
    
    <test id="case10" type="run" file="Case10.Mod" output="Case10.Ref">
      <code>CASE</code> statement with a branch whose labels evaluate
      to the empty set.
    </test>
    
    <test id="case11" type="run" file="Case11.Mod" output="Case11.Ref">
      <code>CASE</code> statement using a character expression, 
      and empty branches.
    </test>
    
    <test id="and1" type="run" file="And1.Mod" output="And1.Ref">
      Testing shortcut evaluation of operator `<code>&amp;</code>'.
    </test>
    
    <test id="or1" type="run" file="Or1.Mod" output="Or1.Ref">
      Testing shortcut evaluation of operator `<code>OR</code>'.
    </test>
    
    <test id="varpar1" type="run"
      file= "HOTVarPar1.Mod" output="HOTVarPar1.Ref">
      Accessing a global variable through a <code>VAR</code> parameter.
    </test>
    
    <test id="inc1" type="run" file="Inc1.Mod" output="Inc1.Ref">
      Performing <code>INC</code> with default delta on global variable.
    </test>
    
    <test id="dec1" type="run" file="Dec1.Mod" output="Dec1.Ref">
      Performing <code>DEC</code> with default delta on global variable.
    </test>
    
    <test id="cap1" type="run" file="Cap1.Mod" output="Cap1.Ref">
      Predefined function <code>CAP</code> for some ASCII characters.
    </test>
    
    <test id="div1" type="run" file="Div1.Mod" output="Div1.Ref">
      Checks that <code>DIV</code> performs rounding to negative
      infinity.  The divisor is positive.
    </test>
    
    <test id="div2" type="run" relevance="informal"
          file="Div2.Mod" output="Div2.Ref">
      Checks result of <code>DIV</code> if the divisor is negative.
    </test>
    
    <test id="mod1" type="run" file="Mod1.Mod" output="Mod1.Ref">
      Checks that <code>MOD</code> performs rounding to negative
      infinity.  The divisor is positive.
    </test>
    
    <test id="mod2" type="run" relevance="informal"
          file="Mod2.Mod" output="Mod2.Ref">
      Checks result of <code>MOD</code> if the divisor is negative.
    </test>
    
    <test id="len1" type="run" file="Len1.Mod" output="Len1.Ref">
      Calling <code>LEN</code> on a 2-dimensional array.  All legal
      argument variants are excercised: without dimension, with
      dimension, and with partially indexed array.  Three different
      kinds of array variables are used: global array variable, open
      array parameter, and partially open array parameter.
    </test>
    
    <test id="len2" type="reject" file="Len2.Mod">
      Calling <code>LEN</code> without arguments.
    </test>
    
    <test id="len3" type="reject" file="Len3.Mod">
      Calling <code>LEN</code> with too many arguments.
    </test>
    
    <test id="len4" type="reject" file="Len4.Mod">
      Calling <code>LEN</code> with non-array argument.
    </test>
    
    <test id="len5" type="reject" file="Len5.Mod">
      Calling <code>LEN</code> with an out of range dimension number.
    </test>
    
    <test id="len6" type="reject" file="Len6.Mod">
      Calling <code>LEN</code> with a non-integer dimension number.
    </test>
    
    <test id="len7" type="reject" file="Len7.Mod">
      Calling <code>LEN</code> with an integer variable as dimension number.
    </test>

    <test id="minmax1" type="run" file="MinMax1.Mod" output="MinMax1.Ref">
      <code>MIN</code> and <code>MAX</code> of the integer types.
    </test>

    <test id="val1" type="run" file="Val1.Mod" output="Val1.Ref">
      Use <code>SYSTEM.VAL</code> to cast a <code>REAL</code> to
      a <code>LONGINT</code>.  This requires some trickery in the C
      back-end, because a type conversion must be prevented.
    </test>
    
    <test id="val2" type="run" file="Val2.Mod" output="Val2.Ref">
      Use <code>SYSTEM.VAL</code> to cast a <code>SET</code> to
      a <code>LONGINT</code>.
    </test>
  </testcases>
  
    
  <testcases profile="OOC2 Development: Checking Anti-Dependencies"
             default-lang="O1 O2 AO">
    <test id="antidep1" type="run" file="AntiDep1.Mod" output="AntiDep1.Ref">
      The record field must be read before it is overwritten.
    </test>
  </testcases>
  
      
  <testcases profile="OOC2 Development: Data Types" default-lang="O1 O2 AO">
    <test id="record1" type="run" file="Record1.Mod" output="Record1.Ref">
      Assignments to the fields of a global record variable.
    </test>
    
    <test id="record2" type="run" file="Record2.Mod" output="Record2.Ref">
      Assignments to the fields of a variable parameter of record type.
    </test>
    
    <test id="record3" type="run" file="Record3.Mod" output="Record3.Ref">
      Assignments to the fields of a value parameter of record type.
    </test>

    <test id="record4" type="run" file="Record4.Mod" output="Record4.Ref">
      Similar to <code>record1</code>, but with part of the record's
      fields taken from a base type.
    </test>
    
    <test id="record5" type="run" file="Record5.Mod" output="Record5.Ref">
      Similar to <code>record2</code>, but with part of the record's
      fields taken from a base type.
    </test>
    
    <test id="record6" type="run" file="Record6.Mod" output="Record6.Ref">
      Similar to <code>record3</code>, but with part of the record's
      fields taken from a base type.
    </test>
    
    <test id="record7" type="run" file="Record7.Mod" output="Record7.Ref">
     Similar to <code>record4</code>, but the variable is allocated
      on the heap.
    </test>

    <test id="record8" type="run" file="Record8.Mod" output="Record8.Ref">
      Similar to <code>record5</code>, but the variable is allocated
      on the heap.
    </test>

    <test id="record9" type="run" file="Record9.Mod" output="Record9.Ref">
      Similar to <code>record6</code>, but the variable is allocated
      on the heap.
    </test>
    
    <test id="record10" type="run" file="Record10.Mod">
      An array variable nested within a record.  This test breaks if
      the array length is not computed before the array size is
      calculated. 
    </test>
    
    <test id="record11" type="error" file="Record11.Mod">
      Assigning to a record variable whose dynamic type does not match
      its static type.
    </test>
    
    <test id="array1" type="run" file="Array1.Mod" output="Array1.Ref">
      Assignments to an <code>ARRAY 3 OF SHORTINT</code>, and a loop 
      summing up the elements.  The array is passed both as value and
      variable parameter to the summation function.
    </test>
    
    <test id="array2" type="run" file="Array2.Mod" output="Array2.Ref">
      As <code>array1</code>, but with <code>INTEGER</code> as element
      type.
    </test>
    
    <test id="array3" type="run" file="Array3.Mod" output="Array3.Ref">
      Fill an 2-dimensional array of <code>INTEGER</code> and write
      the array lines.  The array is a global variable.
    </test>
    
    <test id="array4" type="run" file="Array4.Mod" output="Array4.Ref">
      Like <code>array3</code>, but the array is a parameter with 2
      open dimensions.
    </test>
    
    <test id="array5" type="run" file="Array5.Mod" output="Array5.Ref">
      Like <code>array4</code>, but the array elements are of type
      <code>SHORTINT</code>.
    </test>
    
    <test id="array6" type="run" file="Array6.Mod" output="Array6.Ref">
      Like <code>array1</code>, but the array variable is allocated on
      the heap.  Additionally, summation is also done directly on the
      pointer variable.
    </test>
    
    <test id="array7" type="run" file="Array7.Mod" output="Array7.Ref">
      Like <code>array6</code>, but the variable is an open
      array allocated on the heap.
    </test>
    
    <test id="array8" type="run" file="Array8.Mod" output="Array8.Ref">
      Like <code>array5</code>, but the variable is a 2-dimensional
      open array allocated on the heap.
    </test>

    <test id="procvar1" type="run" file="ProcVar1.Mod" output="ProcVar1.Ref">
      Call procedures through procedure variables.  The procedures
      have no arguments.
    </test>
    <test id="procvar2" type="run" file="ProcVar2.Mod" output="ProcVar2.Ref">
      Call procedures through procedure variables.  The procedures
      have a value and a <code>VAR</code> argument.
    </test>
    <test id="procvar3" type="run" file="ProcVar3.Mod" output="ProcVar3.Ref">
      Call function procedures through procedure variables.
    </test>
    <test id="procvar4" type="run" file="ProcVar4.Mod" output="ProcVar4.Ref">
      Call procedure through procedure variables.  The procedures
      have a value and a <code>VAR</code> argument of type
      <code>RECORD</code>.
    </test>
    <test id="procvar5" type="run" file="ProcVar5.Mod" output="ProcVar5.Ref">
      Call procedure through procedure variables.  The procedures
      have a value and a <code>VAR</code> argument of type
      <code>ARRAY</code>.
    </test>
    <test id="procvar6" type="accept" file="ProcVar6.Mod">
      Assign <code>NIL</code> to a procedure variable.
    </test>

    
    <test id="typetest1" type="run" file="TypeTest1.Mod" output="TypeTest1.Ref">
      Type tests on pointer variables.
    </test>

    <test id="typetest2" type="run" file="TypeTest2.Mod" output="TypeTest2.Ref">
      This is like <code>typetest1</code>, only that the pointer are
      dereferenced and tested against the corresponding record type.
    </test>
    
    <test id="typetest3" type="run" file="TypeTest3.Mod" output="TypeTest3.Ref">
      Type tests on <code>VAR</code> parameters of record type.  The
      record variables are deferenced pointers.
    </test>
    
    <test id="typetest4" type="run" file="TypeTest4.Mod" output="TypeTest4.Ref">
      Like <code>typetest3</code>, but using record variables.
    </test>
  </testcases>

  <testcases profile="OOC2 Development: Procedures" default-lang="O2">
    <test id="tbproc1" type="run" file="TBProc1.Mod" output="TBProc1.Ref">
      Calling a type-bound procedure of a pointer variable.
    </test>

    <test id="tbproc2" type="run" file="TBProc2.Mod" output="TBProc2.Ref">
      Calling a type-bound procedure of a record variable.
    </test>
    
    <test id="tbproc3" type="run" file="TBProc3.Mod" output="TBProc3.Ref">
      Calling a type-bound procedure of a dereferenced pointer variable.
    </test>
    
    <test id="tbproc4" type="run" file="TBProc4.Mod" output="TBProc4.Ref">
      Calling a type-bound procedure of an implictly dereferenced
      pointer variable.
    </test>
    
    <test id="tbproc5" type="run" file="TBProc5.Mod" output="TBProc5.Ref">
      Calling a type-bound procedure of a pointer variable.  The
      procedure is redefined in an extension of the pointer's type.
    </test>
    
    <test id="tbproc6" type="run" file="TBProc6.Mod" output="TBProc6.Ref">
      Calling a type-bound procedure of a pointer variable.  The
      procedure is inherited from the pointer's type.
    </test>

    <test id="tbproc7" type="run" file="TBProc7.Mod" output="TBProc7.Ref">
      Calling a type-bound procedure of a pointer variable.  The
      procedure is redefined in an extension of the pointer's type,
      and the redefinition does a super call.
    </test>

    
    <test id="nestedproc1" type="run"
          file="NestedProc1.Mod" output="NestedProc1.Ref">
      Calling a nested procedure.
    </test>
    
    <test id="nestedproc2" type="run"
          file="NestedProc2.Mod" output="NestedProc2.Ref">
      Calling a nested procedure, which sets a variable of the 
      enclosing procedure.
    </test>
    
    <test id="nestedproc3" type="run"
          file="NestedProc3.Mod" output="NestedProc3.Ref">
      Calling a nested procedure, which sets a variable of the 
      enclosing procedure that is shadowed by one of its parameters.
    </test>

    <test id="opArray1" type="run"  
          file="OpArray1.Mod" output="OpArray1.Ref">
      Exercise array designators.
    </test>

    <test id="opArray2" type="reject" file="OpArray2.Mod">
      Array designator applied to non-array.
    </test>

    <test id="opArray3" type="reject" file="OpArray3.Mod">
      Array indexed by non-integer.
    </test>

    <test id="opArray4" type="reject" file="OpArray4.Mod">
      Constant array index exceeds array length.
    </test>

    <test id="opArray5" type="reject" file="OpArray5.Mod">
      Constant array index is negative.
    </test>

    <test id="opArray6" type="reject" file="OpArray6.Mod">
      Array designator applied to function result.
    </test>

    <test id="opArray7" type="error" file="OpArray7.Mod">
      Accessing an index just after the end of the array.
    </test>

    <test id="opArray8" type="error" file="OpArray8.Mod">
      Accessing index <code>-1</code>.
    </test>

    <test id="opRecord1" type="run" file="OpRecord1.Mod"
       output="OpRecord1.Ref">
      Excercise RECORD operators.
    </test>

    <test id="opRecord2" type="reject" file="OpRecord2.Mod">
      Field selection operator applied to non-RECORD.
    </test>

    <test id="opRecord3" type="reject" file="OpRecord3.Mod">
      Select a field that is not bound to a record type.
    </test>

    <test id="opRecord4" type="reject" file="OpRecord4.Mod">
      Operator applied to function result.
    </test>

    <test id="opPointer1" type="reject" file="OpPointer1.Mod">
      Dereference operator applied to non-pointer.
    </test>

<!--
    <test id="opPointer2" type="reject" relevance="informal" file="OpPointer2.Mod">
      Dereference operator applied to type-bound procedure that does not exist
      in the base type.
    </test>
-->

    <test id="opPointer3" type="run" file="OpPointer3.Mod"
    output="OpPointer3.Ref">
      Super call.
    </test>

    <test id="opPointer4" type="reject" file="OpPointer4.Mod">
      Dereference operator applied to function result.
    </test>

<!--
    <test id="opPointer5" type="reject" relevance="informal" file="OpPointer5.Mod">
      More than one level of "super" call.
    </test>
-->

    <test id="opPointer6" type="error" file="OpPointer6.Mod">
      Dereferencing a <code>NIL</code> pointer.
    </test>

<!--
    <test id="opTypeGuard1" type="run" relevance="informal" file="OpTypeGuard1.Mod"
      output="OpTypeGuard1.Ref">
      Excercise type guards.
    </test> -->

    <test id="opExprCompat1" type="run" relevance="informal" file="OpExprCompat1.Mod"
      output="OpExprCompat1.Ref">
      Excercise combinations of different operand types.
    </test>
    
    <test id="opExprCompat2" type="reject" file="OpExprCompat2.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat3" type="reject" file="OpExprCompat3.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat4" type="reject" file="OpExprCompat4.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat5" type="reject" file="OpExprCompat5.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat6" type="reject" file="OpExprCompat6.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat7" type="reject" file="OpExprCompat7.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat8" type="reject" file="OpExprCompat8.Mod">
      Types are allowed for operator, but not expression-compatible.
    </test>

    <test id="opExprCompat9" type="reject" file="OpExprCompat9.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opExprCompat10" type="reject" file="OpExprCompat10.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opExprCompat11" type="reject" file="OpExprCompat11.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opExprCompat12" type="reject" file="OpExprCompat12.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opExprCompat13" type="reject" file="OpExprCompat13.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opExprCompat14" type="reject" file="OpExprCompat14.Mod">
      Result of numeric operator is "widened" to largest operand.
    </test>

    <test id="opString1" type="run" file="OpString1.Mod" output="OpString1.Ref">
      Test string concatenation operator.
    </test>

    <test id="opString2" type="accept" file="OpString2.Mod">
      Test compatibility of string constant with character and character array
      types.
    </test>

    <test id="opString3" type="accept" file="OpString3.Mod">
      Test compatibility of character constant with character and character
      array types.
    </test>

    <test id="opString4" type="reject" file="OpString4.Mod">
      Test compatibility of character constant with character and character
      array types.
    </test>

    <test id="opString5" type="run" file="OpString5.Mod" output="OpString5.Ref">
      Test comparison operators for character strings.
    </test>

    <test id="opString6" type="run" file="OpString6.Mod" output="OpString5.Ref">
      Test comparison operators for long character strings.
    </test>
  </testcases>
    
  <processor-info processor-name="TestCompile">
    <reject-info id="assign1" pos="%c :=" msg="This must be a variable"/>
    <reject-info id="assign2" pos="r%. TBProc :=" msg="This must be a variable"/>
    <reject-info id="assign3" pos="AssignRO.%x :=" msg="This variable is read-only"/>
    <reject-info id="assign4" pos="AssignRO.y. %a :=" msg="This variable is read-only"/>
    <reject-info id="assign5" pos="x %:= INTEGER" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign6" pos="x %:= Out" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign7" pos="a %:= b" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign8" pos="x %:= NIL" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign9" pos='x %:= "123"' msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign10" pos='p %:= P;' msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign11" pos='p %:= P;' msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign12" pos='p %:= P;' msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign13" pos='p %:= P;' msg="Type of expression is not compatible with variable type"/>
    <reject-info id="assign14" pos='p %:= P;' msg="Type of expression is not compatible with variable type"/>
        
    <reject-info id="return1" pos="RETURN %123" msg="RETURN must not provide a result value"/>
    <reject-info id="return2" pos="%RETURN" msg="RETURN must provide a result value"/>
    <reject-info id="return3" pos="RETURN %128;" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="return4" pos="RETURN %123" msg="RETURN must not provide a result value"/>

    <reject-info id="proc1" pos="%x(" msg="This must be a procedure designator"/>
    <reject-info id="proc2" pos="%P(" msg="This is a function procedure"/>
    <reject-info id="proc3" pos="P(123%)" msg="Too few arguments"/>
    <reject-info id="proc4" pos="%P;" msg="Too few arguments"/>
    <reject-info id="proc5" pos="P(1, 2, %3);" msg="Too many arguments"/>
    <reject-info id="function8" pos=":= %P(" msg="This is not a function procedure"/>

    <reject-info id="if4" pos="IF %b THEN" msg="Expression must be of type BOOLEAN"/>
    <reject-info id="loop7" pos="WHILE str%[i] DO" msg="Expression must be of type BOOLEAN"/>
    <reject-info id="loop8" pos="UNTIL str%[i];" msg="Expression must be of type BOOLEAN"/>
    <reject-info id="loop9" pos="%EXIT" msg="EXIT outside of LOOP"/>

    <reject-info id="for1" pos="a%[0]" msg="Expected symbol `:='"/>
    <reject-info id="for2" pos="FOR %T :=" msg="This must be a variable"/>
    <reject-info id="for3" pos="FOR %x :=" msg="Expression must be of integer type"/>
    <reject-info id="for4" pos=":= %128" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="for5" pos="TO %128 DO" msg="Type of expression is not compatible with variable type"/>
    <reject-info id="for6" pos="BY %128 DO" msg="Step value not in type of loop variable"/>
    <reject-info id="for7" pos="BY %y DO" msg="Expression is not constant"/>
    <reject-info id="for8" pos="BY %0 DO" msg="Step value must not be zero"/>
        
    <reject-info id="case3" pos="CASE %i " msg="Select expression must be integer or character"/>
    <reject-info id="case4" pos="1..%j" msg="Expression is not constant"/>
    <reject-info id="case5" pos="| %128:" msg="Label not in type of select expression"/>
    <reject-info id="case6" pos="| %100X:" msg="Label not in type of select expression"/>
    <reject-info id="case7" pos="| %1(*second*):" msg="Label already in use"/>
    <reject-info id="case8" pos="| 1X, %1X:" msg="Label already in use"/>
    <reject-info id="case9" pos="| 0%..2:" msg="Label already in use"/>
    
    <reject-info id="len2" pos="Int (%LEN " msg="Wrong number of arguments"/>
    <reject-info id="len3" pos="Int (%LEN " msg="Wrong number of arguments"/>
    <reject-info id="len4" pos="LEN (%&quot;abc&quot;"
        msg="Expression must be an array value"/>
    <reject-info id="len5" pos="a, %2),"
        msg="Integer constant in the range `0 &lt;= x &lt; 2' required"/>
    <reject-info id="len6" pos="a, %0X),"
        msg="Integer constant in the range `0 &lt;= x &lt; 2' required"/>
    <reject-info id="len7" pos="a, %d),"
        msg="Expression is not constant"/>
    <reject-info id="opArray2" pos=" %i[0]"
        msg="Expression must be an array value"/>
    <reject-info id="opArray3" pos=" a[%c]"
        msg="Expression must be of integer type"/>
    <reject-info id="opArray4" pos=" a[%4]"
        msg="Integer constant in the range `0 &lt;= x &lt; 2' required"/>
    <reject-info id="opArray5" pos=" a[%-1]"
        msg="Integer constant in the range `0 &lt;= x &lt; 2' required"/>
    <reject-info id="opArray6" pos="P()%[0]"
        msg="Operator may not be applied to function result"/>
    <reject-info id="opRecord2" pos=":= %i."
        msg="Expression must be of record type"/>
    <reject-info id="opRecord3" pos="p.%r :="
        msg="Undeclared identifier"/>
    <reject-info id="opRecord4" pos="New(1)%.i"
        msg="Operator may not be applied to function result"/>
    <reject-info id="opPointer1" pos=":= %i"
        msg="Expression must be of pointer type"/>
    <reject-info id="opPointer4" pos="New(1)%"
        msg="Operator may not be applied to function result"/>
    <reject-info id="opExprCompat2" pos=" %+"
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat3" pos=" %+"
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat4" pos=" %+"
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat5" pos=" %DIV"
        msg="Invalid type for operator"/>
    <reject-info id="opExprCompat6" pos=" %="
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat7" pos=" %="
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat8" pos=" %="
        msg="Incompatible types for operator"/>
    <reject-info id="opExprCompat9" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opExprCompat10" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opExprCompat11" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opExprCompat12" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opExprCompat13" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opExprCompat14" pos=" %:="
        msg="Type of expression is not compatible with variable type"/>
    <reject-info id="opString4" pos=" c %:="
        msg="Type of expression is not compatible with variable type"/>

  </processor-info>
</testsuite-ext>
