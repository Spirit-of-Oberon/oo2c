Syntax:

  TPSection  = ident {"," ident} ":" Qualident.
  TypePars   = "<" [TPSection {";" TPSection} ] ">".
  TypeDecl   = IdentDef [TypePars] "=" Type ";".

  QualType   = Qualident ["<" [QualType {"," QualType}] ">"].
  Type       = QualType|ArrayType|RecordType|PointerType|ProcType.
  RecordType = "RECORD" ["("QualType")"] ... "END".  
  FormalPars = [ "(" [FPSection {";" FPSection}] ")" [":" QualType] ].
         
A type declared with a type parameter list like
`T<t1:B1,t2:B2,...,tn:Bn>' is called a `parametric type'.  The formal
type Bi of a type parameter declaration is called a type bound.  It
must be a record pointer.  A type name ti is visible to the end of the
type declaration, and within all type-bound procedures whose receiver
type is T.

For a qualified type expression of the form `T<A1,A2,...,An>',

  a) the type T must be a parametric type,

  b) it must have the same number of type arguments as there are type
      parameters, and

  c) each actual type parameter Ai is either an extension of the
     corresponding type bound Bi, or Ai is a type variable whose bound
     is an extension of Bi.

If T is a parametric type as defined above, then the type expression
`T' is equivalent to the qualified type `T<B1,B2,...,Bn>', where each
type argument equals the corresponding type bound.


Within a type-bound procedure, a variable `v:Ti', with ti declarared
with a type bound `ti:Bi', can for the most part be used like it had
been declared as `v:Bi'.  The exceptions are that it can only be
assigned values of type `Ti' (or NIL), and that NEW is not applicable
to such a variable.

A type variable cannot be used on the right hand side of a type test
or type guard.

Note: Some of the restrictions on type variables and qualified types
follow the assumption that no type information for parametric types is
available during run-time.



Type Declarations
=================

TYPE T<...> = ...;

ACCEPT

  1) T<A: Object> = ARRAY OF A  [Generic2]
  2) T<A, B: Object> = RECORD a: A; b: B END  [Generic3]
  3) T<A: Object; B: AnotherObject> = RECORD a: A; b: B END  [Generic3]
  4) T<> = RECORD END  [Generic3]
  5) Extension of a parametric record type.  [Generic4]
  6) T.t visible in type-bound procedure.  [Generic1]

REJECT

  1) Type bound is not a record pointer.  [Generic5]
  2) Reference to type variable after declaration.  [Generic6]
  3) Reference to type variable in extended type.  [Generic7]
  4) Reference to type var of pointer base in type-bound proc.  [Generic14]
  5) Reference to type var in type-bound proc of extension.  [Generic15]

Qualified Types
===============

VAR x: T<...>;

ACCEPT

  1) Instance of record and types with arguments.  [Generic2 Generic3]
  2) Instance of parametric type without arguments.  [Generic3]
  3) Argument is a type variable with matching bound.  [Generic1]

REJECT

  1) T is not a parametric type.  [Generic8]
  2) Too few or too many type arguments.  [Generic9 Generic10]
  3) Type argument is not an extension of the type bound.  [Generic11]
  4) Type argument's bound is not extension of parameter bound.  [Generic12]

Type Variables
==============

VAR v, w: T.ti;

ACCEPT

  1) v := NIL  [Generic16]
  2) v := w  [Generic16]
  3) P(v,w)  [Generic16]
  4) w := F(v) & RETURN v  [Generic16]
  5) x := v if bound of `v' is extension of type of `x'
  6) y := v(S) where S is an extension of the bound of `v'
  7) v.TBProc()
  8) v.f
  9) v=w, x=v, v=NIL

REJECT

  1) Assigning v a value of its type bound.  [Generic17]
  2) Type test or guard using a type variable.  [Generic18 Generic19]
