MODULE AllModules;

IMPORT
(* Miscellaneous Modules
   ------------------------------------------------------------------------ *)
  OOC:Error,
    (* Handles error lists for the compiler. It is specialization of 
       @omodule{Msg}.  *)
    
    
(* Scanner
   ------------------------------------------------------------------------ *)
  OOC:Scanner:Symbol,
    (* Defines symbolic names for the symbols recognized by the parser.
       Provides mappings from symbol id to symbol name and symbol
       representation.  *)
       
  OOC:Scanner:InputBuffer,
    (* Provides the buffering mechanism for the scanner module.  *)
    
  ScannerBuilder := OOC:Scanner:Builder,
    (* Builder interface for the scanner module.  The scanner calls factory
       methods from this module to create symbol objects.  *)
       
  OOC:Scanner,
    (* This is the module that does the actual scanning work.  It reads a
       file and calls the factory methods of the builder to create a symbol
       instance for every token it recognizes.  *)
       
       
  OOC:Scanner:Builder:BasicList,
    (* This builder module creates a list of symbols from the scanner's data.
       This list is subsequently fed to @oproc{OOC:Parser.Module}.  *)
       
  OOC:Scanner:Builder:Identity,
    (* Debugging builder: Writes symbols unchanged to the output channel.  *)
    
  OOC:Scanner:Builder:Statistics,
    (* Displays some statistics about the symbols used in the source text.  *)
    
  ScannerXML := OOC:Scanner:Builder:XML,
    (* Debugging builder: Converts list of symbols generated by the scanner
       into an XML document.  Every symbol becomes an element, with the
       symbol's attributes appearing in the element's start tag.  *)
       
  
(* Abstract Syntax Tree
   ------------------------------------------------------------------------ *)
  OOC:AST,
    (* Defines the abstract builder class that is used by the parser to
       register parsed objects.  For every production of the Oberon-2 syntax,
       there exists a corresponding factory method.  *)
  
  OOC:AST:ExtTree,
    (* Concrete implementation of the builder interfaces defined by 
       @omodule{OOC:AST}.  It creates an abstract syntax tree that is
       a one-to-one representation of the data passed that is passed to 
       the builder by the parser.  *)
  
  OOC:AST:ExtTree:CreateSymTab,
    (* Creates the symbol table from the abstract syntax tree defined by
       module @omodule{OOC:AST:ExtTree}.  Uses the factory methods of
       @omodule{OOC:SymbolTable:Builder} to populate the symbol table.  *)
  
  ExtTreeXML := OOC:AST:ExtTree:XML,
    (* Writes an abstract syntax tree into an XML document that describes the
       structure of the syntax tree.  The only information lost is formatting,
       comments, and pragmas.  *)
  
  OOC:AST:ExtTree:StupidPP,
    (* A simple pretty printer: It writes the abstract syntax tree to the
       output channel, omitting any comments.  The output is the complete
       contents of the source module, using a very rigid indentation and
       formatting style.  *)


(* Parser
   ------------------------------------------------------------------------ *)
  OOC:Parser,
    (* Parses an Oberon-2 module and creates an abstract syntax tree by
       calling the appropriate builder methods of @otype{OOC:AST.Builder}.
       This module exports a single procedure, @oproc{OOC:Parser.Module},
       whose result is the root of the constructed syntax tree.  *)


(* Symbol Table
   ------------------------------------------------------------------------ *)
  OOC:SymbolTable:Item,
    (* Defines the entries and structure of the standard symbol table.
       Provides the basic namespace interface, and the basic infrastructure
       for storage and retrieval of persistent symbol table data.  *)
  
  OOC:SymbolTable:Item:XML,
    (* Writes a symbol table to an XML document.  *)
  
  SymbolTableBuilder := OOC:SymbolTable:Builder,
    (* Defines a builder class with factory methods for the symbol table
       entries defined in @omodule{OOC:SymbolTable:Item}.  *)
  
  OOC:SymbolTable:Predef,
    (* Defines symbol table of pseudo module with predefined entities,
       like @samp{CHAR} or @samp{COPY}.  *)
  
  OOC:SymbolTable:TypeRules,
    (* Defines the type rules of the language.  *)

  OOC:SymbolTable:Namespace,
    (* This module defines the module, procedure, and record namespaces.  It
       also implements semantic checks on these namespaces.  *)
       
  OOC:SymbolTable:CreateNamespace,
    (* Converts a raw symbol table, as derived from the module by the parser,
       into a fully fledged symbol table with namespace information, and
       replaces type names with the actual type.  Any error in a module's
       declarations are reported by this module.  *)



  OOC:SymbolTable:Item:GetClass,
  OOC:Repository,
  RepFileSystem := OOC:Repository:FileSystem,
  
  OOC:Config:Pragmas,
  OOC:Config:Pragmas:StdPragmas,
  
  OOC:Config:Repositories,
  ConfigRepFileSystem := OOC:Config:Repositories:FileSystem,
  
  (* there is no code to handle operator trees yet, these modules are 
     completely defunct... *)
  OOC:OpTree,
  OOC:OpTree:Operator,
  OOC:OpTree:Value,
  OOC:OpTree:StdOpTree,

  OOC:Make,
  OOC:Make:SyncDispatcher,
  OOC:Make:Node:ModuleOutput,
  OOC:Make:BuildCmd:InterfaceXML,
  OOC:Make:Edge:TimeStampDep,
  
  OOC:Auxiliary:ParseModule,
  
(* Test Programs
   ------------------------------------------------------------------------ *)
  TestScanner, TestParser, TestSymTab, TestConfigSections, TestConfigCmdLine,
  TestConfigEnv, TestConfigSimple, TestInterfaceGen, TestTexinfo, TestOpTree;
  
END AllModules.
